package me.bebeli555.cookieclient.mods.exploits;

import me.bebeli555.cookieclient.Mod;
import me.bebeli555.cookieclient.events.bus.EventHandler;
import me.bebeli555.cookieclient.events.bus.Listener;
import me.bebeli555.cookieclient.events.other.PacketPostEvent;
import me.bebeli555.cookieclient.events.player.PlayerMoveEvent;
import me.bebeli555.cookieclient.events.player.PlayerUpdateEvent;
import me.bebeli555.cookieclient.gui.Group;
import me.bebeli555.cookieclient.gui.Mode;
import me.bebeli555.cookieclient.gui.Setting;
import net.minecraft.client.entity.EntityOtherPlayerMP;
import net.minecraft.entity.Entity;
import net.minecraft.network.play.client.*;
import net.minecraft.util.math.Vec3d;
import net.minecraftforge.event.entity.EntityJoinWorldEvent;

public class FreecamWithPackets extends Mod {
    public static Setting mode = new Setting(null, "Mode", "Normal", new String[]{"Normal"}, new String[]{"Camera"});
    public static Setting cancelPackets = new Setting(Mode.BOOLEAN, "CancelPackets", true);
    public static Setting speed = new Setting(Mode.DOUBLE, "Speed", 1);

    private Entity riding;
    private EntityOtherPlayerMP camera;
    private Vec3d position;
    private float yaw;
    private float pitch;

    public FreecamWithPackets() {
        super(Group.EXPLOITS, "FreecamWithPackets", "Freecam that can be used to perform some dupes", "If you want real freecam then use the one in render section");
    }

    @Override
    public void onEnabled() {
        if (mc.world == null) {
            this.toggle();
            return;
        }

        if (mode.stringValue().equals("Normal")) {
            this.riding = null;
            if (mc.player.getRidingEntity() != null) {
                this.riding = mc.player.getRidingEntity();
                mc.player.dismountRidingEntity();
            }

            camera = new EntityOtherPlayerMP(mc.world, mc.getSession().getProfile());
            camera.copyLocationAndAnglesFrom(mc.player);
            camera.prevRotationYaw = mc.player.rotationYaw;
            camera.rotationYawHead = mc.player.rotationYawHead;
            camera.inventory.copyInventory(mc.player.inventory);
            mc.world.addEntityToWorld(-100, camera);

            this.position = mc.player.getPositionVector();
            this.yaw = mc.player.rotationYaw;
            this.pitch = mc.player.rotationPitch;

            mc.player.noClip = true;
        } else {
            camera = new EntityOtherPlayerMP(mc.world, mc.getSession().getProfile());
            camera.copyLocationAndAnglesFrom(mc.player);
            camera.prevRotationYaw = mc.player.rotationYaw;
            camera.rotationYawHead = mc.player.rotationYawHead;
            camera.inventory.copyInventory(mc.player.inventory);
            camera.noClip = true;
            mc.world.addEntityToWorld(-100, camera);
            mc.setRenderViewEntity(camera);
        }
    }

    @Override
    public void onDisabled() {
        if (mc.world != null && mode.stringValue().equals("Normal")) {
            if (this.riding != null) {
                mc.player.startRiding(this.riding, true);
                riding = null;
            }

            if (this.camera != null) {
                mc.world.removeEntity(this.camera);
            }

            if (this.position != null) {
                mc.player.setPosition(this.position.x, this.position.y, this.position.z);
            }

            mc.player.rotationYaw = this.yaw;
            mc.player.rotationPitch = this.pitch;
            mc.player.noClip = false;
            mc.player.setVelocity(0, 0, 0);
        } else if (mode.stringValue().equals("Camera")) {
            if (this.camera != null) {
                mc.world.removeEntity(this.camera);
            }

            mc.setRenderViewEntity(mc.player);
        }
    }


    @EventHandler
    private Listener<PlayerMoveEvent> playerMoveEvent = new Listener<>(e -> {
        if (mode.stringValue().equals("Normal")) {
            mc.player.noClip = true;
        }
    });

    @EventHandler
    private Listener<PlayerUpdateEvent> playerUpdateEvent = new Listener<>(e -> {
        if (mode.stringValue().equals("Normal")) {
            mc.player.noClip = true;
            mc.player.setVelocity(0, 0, 0);
            final double[] dir = getSpeed(speed.doubleValue());

            if (mc.player.movementInput.moveStrafe != 0 || mc.player.movementInput.moveForward != 0) {
                mc.player.motionX = dir[0];
                mc.player.motionZ = dir[1];
            } else {
                mc.player.motionX = 0;
                mc.player.motionZ = 0;
            }

            mc.player.setSprinting(false);

            if (mc.gameSettings.keyBindJump.isKeyDown()) {
                mc.player.motionY += speed.doubleValue();
            }

            if (mc.gameSettings.keyBindSneak.isKeyDown()) {
                mc.player.motionY -= speed.doubleValue();
            }
        }
    });

    @EventHandler
    private Listener<EntityJoinWorldEvent> entityJoinWorldEvent = new Listener<>(e -> {
        if (e.getEntity() == mc.player) {
            this.toggle();
        }
    });

    @EventHandler
    private Listener<PacketPostEvent> packetPostEvent = new Listener<>(e -> {
        if (mode.stringValue().equals("Normal") && cancelPackets.booleanValue()) {
            if ((e.packet instanceof CPacketUseEntity) || (e.packet instanceof CPacketPlayerTryUseItem) || (e.packet instanceof CPacketPlayerTryUseItemOnBlock) || (e.packet instanceof CPacketPlayer) || (e.packet instanceof CPacketVehicleMove)) {
                e.cancel();
            }
        }
    });

    public static double[] getSpeed(double speed) {
        float forward = mc.player.movementInput.moveForward;
        float side = mc.player.movementInput.moveStrafe;
        float yaw = mc.player.prevRotationYaw + (mc.player.rotationYaw - mc.player.prevRotationYaw) * mc.getRenderPartialTicks();

        if (forward != 0) {
            if (side > 0) {
                yaw += (forward > 0 ? -45 : 45);
            } else if (side < 0) {
                yaw += (forward > 0 ? 45 : -45);
            }
            side = 0;

            if (forward > 0) {
                forward = 1;
            } else if (forward < 0) {
                forward = -1;
            }
        }

        final double sin = Math.sin(Math.toRadians(yaw + 90));
        final double cos = Math.cos(Math.toRadians(yaw + 90));
        final double posX = (forward * speed * cos + side * speed * sin);
        final double posZ = (forward * speed * sin - side * speed * cos);
        return new double[]{posX, posZ};
    }
}
